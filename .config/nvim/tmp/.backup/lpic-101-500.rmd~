---
title: Linux  Perfesional Institute 101-500
author: Ryan Michael Sullivan
output: pdf_document
---

# 101 System Architecture

## 101.1 Determine and configure hardware settings

### Commands for Inspection: Identify connected devices
  * lspci (Peripherals Component Interconnect):
    - PCI devices can be components attached to the motherboard, like a disk controller,
      or expansion cards fitted into PCI slots, like discrete graphics
    - lspci -s **HEX_IDENTIFIER** -v — displays more details about device -s **identifier**
    - Can be used to find used or needed kernel modules

  * lsusb (Universal Serial Bus)
    - devices currently connected to machine
    - USB interface is largely used for connecting input devices & removable media
    - lsusb -v -d **DEVICE_ID** — to select device to display more detail
    - lsusb -t — used to displays hierarchical tree
    - lsusb -s **BUS_No/DEV_No** if 2 categories hard drivers, look up w/both identifiers 

  * Preferable way to interact w/large set of loaded kernel modules is w/Commands
    from the **kmod** package
  * kmod: set of tools to handle common tasks w/Linux Kernel modules
    - lsmod: shows all currently loaded commands
    - modprobe: can be used to load & unload modules
    - modinfo: used to show description of modules
               modinfo -p shows all available parameters
    - persistant parameters for modules are set in */etc/modprobe.conf* or individually
      in */etc/modprobe.d/**module_name.conf***

### Information & Device Files
  * the commands **lspci**, **lsusb**, **lsmod** display info kept in files in
    */proc* & */sys*
    - used to store mount points for runtime configuration store in RAM
  * */sys*: stores device & kernel info related to hardware
  * */proc*: stores info on device & kernel data structures, including running process & configuration
    - */proc/cpuinfo*: Lists detailed info on CPU(S) found in OS
    - */proc/interrupts*: Lists number of interrupts per IO device per CPU
    - */proc/ioports*: Lists currently registered I/O port regions in use
    - */proc/dma* : Lists registered DMA (direct memory access) channels in use
  * */dev*: every file contained corresponds to a system device
    - **EX:** legacy IDS hard drives appear as */dev/hda#*
  * udev: handles removable device, creates corresponding files in */dev*
    - responsible for identification/configuration of (cold-plug detection)
    — i.e. present during power-up — and (hot-plug devices)
      identified while system is running
    - relies on **sysFS**, the psudo filesystem for hardware in /sys
    - */etc/udev/rules.d* udev searches for and stores rules for hot-plugged devices here
    - */dev/hda* & */dev/hdb* are reserved for master/slave devices on first IDE
    - */dev/hdc* CD/DVD device
    - */dev/fd#* floppy drive
    - */dev/sda* SCSI device
    - */dev/mmcblk* SD card
    - */dev/nvme* nvme ssd


## 101.2 Boot the System

### BIOS and UEFI
  * Procedures executed by x86 machines to bootloader differ on BIOS vs UEFI

  * BIOS: stored in non-volatile memory chip on motherboard, executed every startup
    - Assumes that first 440b first in storage device are bootstrap — bootloader first stage 
    - MBR (Master Boot Record): first 512M of storage device  using DOS partition schema

    - General pre-operating steps to boot BIOS system
      1) POST (power-on self-test) executed to identify hardware failures
      2) BIOS activates basic components to load system i.e. storage, peripherals, video
      3) BIOS loads first stage of bootloader from MBR
      4) first stage of bootloader calls second stage, responsible for boot options & kernel loading

  * UEFI: Does not rely on MBR, only considering setting in NVRAM (non-volatile memory)
          on motherboard
    - these indicate location of EFI — UEFI compatible programs — executed automatically
      or called from bootloader
    - standard compatible filesystems are FAT[12/16/32]
    - ESP: EFI System partition containing EFI programs

    - General pro-operating system boot steps on UEFI systems
      1) POST (power-on self-test) executed to identify hardware failures
      2) UEFI activated basic components to load system i.e. storage, peripherals, video
      3) firmware reads NVRAM to execute pre-defined programs on ESP, usually bootloader
      4) if bootloader, it will load kernel and start OS

### The Bootloader
  * GRUB (Grand Unified Bootloader) most popular on Linux
    - can choose kernel to load or pass parameters in form *option=value*
  * useful kernel parameters
    - acpi: Enable/Disable ACPI support
    - init: set system initiator — i.e. init=/bin/bash initiates w/bash
    - systemd.unit: set systemd target to activate — i.e. systemd=graphical.target
                    also accepts runlevels as defined for **SysV**
    - mem: set amount of available RAM — i.e. mem=512M
    - maxcpus: Limits number of processors (or cores) visible to system
    - quiet: hides boot messages
    - vga: selects video mode
    - root: set root partition
    - rootflags: mount options for rootfs
    - ro: mount root as read-only
    - rw: mount root as read-write
  * can see loaded parameters in file */proc/cmdline*

### System Initaliation
  * A minimum feature set for these scripts/daemons are start/stop/restart services
    - Initialization of OS starts when bootloader loads kernel into RAM
    - kernel opens initramfs (initial RAM filesystem) — an archive containing filesystem
      used as temp root during boot process
    - When main filesystem available, kernel mounts */etc/fstab* then execute init

  * Sysv standard
    - Service manager, based on SysVinit standard, controls runlevels to manage startup
      daemons/resources
    - Runlevels: 0-6 — 0, 1, 6 universal — rest by distribution

  * SystemD
    - Modern system and service manager w/compatibility layer for SysV commands/runlevels
    - concurrent structure
    - employs sockets & D-Bus for service activation
    - on-demand daemon execution
    - cgroups for process monitoring
    - snapshot support
    - session recovery
    - dependency-based service controls
    - mount point control

  * Upstart
    - Init program focused on speeding up boot process w/parallelization of loading services

### Initialization Inspector
  * Errors may be non-fatal and give valuable info to tune the system
  * Kernel Ring Buffer: area kernel stores messages, like from boot
    - this is volatile memory
    - *dmesg* — displays current messages in buffer
    - *dmesg --clear* — clear buffer
    - *dmesg --human* — display in pager like format; use instead of pipe to less
  * **journalctl** — command on systemd to sort messages
    - *journalctl --list-boots* — boot number relative to current boot, identification
      hash, first & last message timestamps
    - *-b, —boot, -k, —dmesg*
    - *-boot=0* — messages form current boot, counting up for each previous stored
  * */var/log* — stores messages from OS
    - *journalctl --directory* — read logs outside */var/log/journal*


## 101.3 Change runlevels/boot targets and shutdown or reboot
  * Any OS following the UNIX philosophy will have various daemons to handle each
    function, which need to be modifiable at runtime by a service management utility
  * PID 1 — the service management is the first serviced launched by the kernel
  
### SysVinit
  * standard provides set of states called runlevels & their corresponding
    services to be executed
  * level 0 — system shutdown
  * level 1 — (single) user mode, without non-essentials i.e. networking
  * level 2-4 — Multi-user mode, login by console or network, 2 & 4 not often used
  * level 5 — Multi-user mode, equivalent to 3 plus graphical mode login
  * level 6 — system restart
  
  * */sbin/init* — responsible for managing runlevels & associated daemons/resources
    - During Initialization, **init** program identifies requested runlevel, defined
      by kernel parameters or in */etc/inittab*
    - loads scripts associated w/runlevel
    - **SYNTAX EX:** */etc/inittab*
    - **id:runlevels:action:process**
    - *id*: Generic 4 char identifier
    - *runlevels*: 0-6
    - *action*: how init will execute *process*
  * *actions* available
    - boot: executed during initialization, ignores runlevel
    - bootwait: executed during initialization, init wait for it to finish
    - sysinit: executed after initialization, regardless of runlevel
    - wait: executed for given runlevels, init will wait for it to finish
    - respawn: process will restart if terminated
    - ctrlaltdel: send SIGINT signal, triggered by the key-combination
  * **telinit q** command should be executed after modifying *etc/inittab*
    - argument q tells init to reload config
  * */etc/init.d/* — scripts for each runlevel
  * each run level has */etc/rc#.d/* where # is runlevel number
    - these files are symlinks
    - starting letter decides behavior
    - K — kill when enter runlevel
    - S — start when enter runlevel
  * both *init* & *telinit* can alternate runlevel during runtime
    - *telinit 1* — change to runlevel 1; also with *telinit s/S*

### SystemD
  * manages resources & services, referred to as units
  * *Unit* consists of name, type, & configuration file

  * **Seven types of systemd units**
    - service — for activate system resources which can be initialized, interrupted, & reloaded
    - socket — con be filesystem/network socket, has corresponding service unit
    - device — associated w/hardware device, device will on be taken as unit w/udev rule
    - mount — mount point in filesystem, line in */etc/fstab*
    - automount — also mount point in filesystem, auto mounted, has corresponding mount unit
    - target — grouping of units managed by single unit
    - snapshot — saved state of systemd manager, not ubiquitous feature
  * *systemctl* main command for controlling systemd units
    - **EX:** *systemcgl isolate multi-user.target* will manually start runlevel 3
    - systemd also has corresponding runlevel#.target
    - does **not** use */etc/inittab*
  * initab like behavior with systemd.unit kernel parameter
    - **EX:** *systemd.unit=multi-user.target*
    - can also modify symlink in */etc/systemd/system/default.target*
  * */lib/systemd/system/* — configuration files for each unit
  * */etc/systemd/logind.conf* — configuration for hibernation modes
      - */etc/systemd/logind.con.d* — same thing but for individual files

### Upstart
  * */etc/init* upstart initialization scripts
  * *initctl list* list services w/their state
  * does **not** use */etc/inittab*
  * accepts legacy command *telinit* & *runlevel*

### Shutdown and Restart
  * *shutdown* — notifies all logged in users with warning & new logins are prevented
    - acts as intermediary to init system procedures
    - after shutdown all processes receive a SIGTERM followed by SIGKILL, tel shutdown/runlevel change
    - default *no -h or -r* alternates to runlevel 1
    - syntax *shutdown [option] time [message]* only time is required
    - time *hh:hh* or *+m* or *now*/*+0*
  * */etc/shutdown.allow* — usernames allowed to shutdown w/ctrlaltdel
  * systemctl can also be used
  * *wall* command, sends message to all logged in users


# 102: Linux installation and Package management

## 102.1 Design hard disk layout
  * partition table: contains info on each partition on disk
  * the filesystem determines how data is actually stored to disk
  * partitions can be combined across disk with LVM (Logical Volume Manager)
    - logical ones can with filesystems like btrfs

### partitioning
  * keeping /boot separate allows booting in case of root crash
  * separate /home allows reinstalling root in case of problem
  * separate /var (used for web/database) makes administrative tasks easier
  
  * boot partition usually first because original IBM PC BIOS addressed disks using
    *cylinders, heads, and sectors* (CHS) w/max of 1024 cylinders, 256 heads, & 63 sectors 
    resulting in max disk space of 528M (504M under MS-DOS)
    - anything beyond  this inaccessible in legacy system without addressing scheme like (LBA)
      Logical Block Addressing
    - for compatibility, boot is usually first partition w/max size of 528M
    - usually small, 300M is a good size today
  
  * (ESP) EFI System partition — formatted with FAT, on GUID, has globally unique identifier
    *C12A7328-F81F-11D2-BA4B-00A0C93EC93B*, w/MRB has partition ID *0xEF*
  * */var* — variable data
    - */var/log* — system logs
    - */var/tmp* — temporary files
    - */var/cache* — application cache
    - */var/ww/html* — web server
    - */var/lib/mysql* — myaql server
    - might want separate to protect disk from filling die to over logging 

  * LVM — form of storage virtualization aimed to facilitate managing users storage needs
    - (PV) Physical volumes — block device on system; partition or RAID array
    - (VG) Volume Group — abstracts multiple physical devices into logical device
    - *extents* — VG is broken into ficed-size pieces
    - (PE) Physical Extents — extents on PV
    - (LE) Logical Extents — extents on LV, each mapped to PE
    - VG can de subdivided into LVs
    - LV is defined by size of PE; 4M by default


## 102.2 Install a boot manager
  
### GRUB2
  * complete rewrite of legacy to be cleaner, safer, more robust/powerful w/flexible configuration
  * GPT - created to deal w/these limitations, compatible w/GRUB & UEFI
    - */etc/grub.d/40_custom* — custom menuentries
    - */etc/grub.d/10_linux* — themes

 * Contents of /boot
    - Config file — stores kernel configuration parameters
    - System map — look-up table matching symbol names to memory addresses, useful to debug kernel panic
    - Linux kernel — installed Linux kernel(s)
    - Initial RAM disk — minimal rootfs loaded to RAM w/modules needed to mount root
    - Bootloader files — bootloader config files and modules

  * **EX:** GRUB cmdline
    - *root=(hd0,1)* — hd count from 0, partitions count from 1
    - *ls* fo find disk — *ls (hd0, msdos1)/* to confirm contents
    - *ls -l /dev/disk/by-uuid* & *search —no-floppy --set=root --fs --uuid PARTUUID*
    - *set root=(hd0,msdos1)* — manually identify root
    - *linux /vmlinuz root=/dev/sda1* — load kernel
    - *initrd /initrd.img* — load initial RAM disk
  * rescue steps, use previous to identify drives &
    - *set prefix=(hd0,msdos1)/boot/grub* — boot from rescue shell
    - *insmod normal* & *insmod linux* — load normal & linux modules after rescue
    - *set root=* then load kernel and initrd

### Legacy GRUB
  * developed in 1995 from the GNU Hurd project, replacing things like LILO
  * bootstrap is loaded first, calling disk bootloader, usually in 32K space between MRB & sda1
  * GrubL lacks universal support for UUIDS w/max partition size of 3 primary, 1 extended
    & max dick size of 2T
    - use */dev/sda* since no universal UEFI support
    - (hd1,0) — unlike GRUB2, both numbers count from 0
    - */boot/grub/menu.lst* — menuentries
    - *root (hd0,0)* — set device containing */boot*
    - *find /boot/grub/stage1* — look for where */boot* is
    - *setup (hd0)* — setup GRUB after locating */boot*

  * Chainloading other OS — legacy GRUB process to load unsupported OS
    - similar syntax to normal entry plus the following
    - makeactive — set flag indicating this is active partition, only work on DOS primary partitions
    - chainload +2 — tells GRUB load first sector of */boot*
    - boot — run bootloader & load corresponding OS


### 102.3 Manage shared libraries
  * shared libraries *libNAME.so.version#*
  * static libraries *libNAME.a.version#*
  * common locations for shared libraries
    - */lib*
    - */lib32*
    - */lib64*
    - */usr/lib*
    - */usr/local/lib*
  * configure library path for dynamic linker *ld-linux.so* in */etc/ld.so.conf*/*/etc/ld.conf.d*
    - entries must have absolute path of shared libraries
  * *ldconfig* — program to read configs and make symlinks with */etc/ld.so.cache*
    - **LD_LIBRARY_PATH=/usr/local/mylib** — set custom library PATH
  * **ldd** — look up shared libraries for executable
    - *-u* — flag to see unused libraries
    - can be investigated w/**readelf** & **objdump**


## 102.6 Linux as a virtualization guest

### Virtualization
  * process of allowing *hypervisor* to run process containing fully emulated computer systems
    - responsible for managing physical resources of virtual machines, called "quests"
  
  * Hypervisors — allow for dynamic reallocation of virtual machine
    - Migration: process of moving form one hypervisor installation to another
    - Live Migration: migration performed while guest running

  * Xen — open source type 1 hypervisor
    - type 1 — does not rely on underlying OS functions
    - this type known as *bare-metal* since computer can directly boot into

  * KVM (Kernel Virtual Machine) — kernel module for virtualization
    - both type 1 & 2 — although needs generic Linux OS to work, able to perform
      by integrating w/running Linux
    - deployed using libvert daemon

  * VirtualBox — application to create & manage virtual machines
    - type 2 — requires underlying OS to work; cross-platform

### Types of Virtual Machines
  * Fully Virtualized — all expected instructions **MUST** be run in virtualized OS
    - no installed drivers to translate instructions
    - guest unaware it is running in VM
    - this type needs appropriate cpu extensions enabled in BIOS/UEFI

  * Paravirtualized — paravirtualized guest (PVM) is where OS is aware of VM instance
    - makes use of modified kernel and specific drivers (guest drivers)
    - often better performance than fully virtualized guest due to drive advantage

  * Hybrid — combine fullyV & paraV to allow unmodified OS to receive near native I/O
    - attached w/paraV drivers on fullyV OS

### Types of Images
  * COW — Copy-on-write (thin-provisioning/sparse images)
    - method where disk file has predefined upper size
    - size only increase when new data written

  * RAW — full disk type
    - file with all space pre-allocated
    - performance benefit over COW but needs space regardless of use
    - allows hypervisor to write without monitoring image limit

### Working with virtual machine templates
  * since VMs are files, templates are great way to deploy quickly

  * D-Bus Machine ID
    - machine ID generated at install
    - new one generated when cloning VM
    - *dbus-uuidgen --ensure* — to validate for system
    - *dbus-uuidgen --get* — view current ID
    - */var/lib/dbus/machine-id* — ID location

### deploying VMs to the Cloud
  * Computing Instances
    - many cloud providers rate based on "computing instances" or CPU time
    - Instances also refer to number of VMs provisioned in cloud environment

  * Block Storage
    - size and speed of storage are also variable
    - archive storage is very inexpensive

  * Networking
    - One of main components of cloud service
    - must configure DNS & FQDN (Fully Qualified Domain Names)
    - hybrid — connect existing network to cloud w/VPN

  * Securely Accessing Guests in the Cloud
    - SSH — most often method to access remote virtual guest
    - *ssh-copy-id -i <public_key> user@cloud_server* — get key from server

  * cloud-init
    - tool along w/configuration files & per-defined VM images is vendor neutral
      method to quickly deploy Linux guest
    - configuration in YAML

### Containers
  * An isolated environment to deploy an application
    - Just enough to run application
  * Can be migrated from host to host
  * Deploy multiple versions of application in tandem
  * Make us of cgroups (control groups)
    - allow partitioning of resources for application


# 103: GNU and Unix Commands

## 103.2 Process text streams using filters
  * Use "double" to preserve value except for special char; use for variable value
  * use 'single' to get exact literals in quotes
    - **EX:** '$myvar'->$myvar — "$myvar"->value
  * bzcat — cat for bzip compressed files
  * xzcat — cat for xz compressed files
  * zcat — cat for gzip compressed files
  * pagers are helpful to parse streams
    - less — generally used
    - head — get head of stream
    - tail — get tail of stream
  * sed — can be used instead of cat > grep
    - standard stream editor

  * Verifying file integrity
    - can be done using checksums
    - **EX:** *sha256sum -c $(sha256sum file)* — to verify sha256 checksum

  * od (octal dump) command
    - lists file contents in octal
    - used to debug files/applications
    - *byte offset* — first column, 8-bit offset
    - *-x* flag, everything after offset in hexadecimal


## 103.3 Perform basic file management

### Types of Files
  * Regular — store data & programs
    - *-* represents regular
  * Directories — contain files
    - *d* represents directory
  * Special — used for i/o
    - *c* represents special

  * Recursive Manipulation of Files and Directories
    - usually *-r*, *-R*, or *—recursive*

### File Globbing and Wildcards
  * Feature of Unix to represent multiple filenames w/special characters
    - symbols to substitute for one or more files

  * **Types of Wildcards**
    - *(asterisk) — represents 0 or more or any char
    - ?(question mark) — represents single occurrence of any char
    - [](brackets) [a-z][0-9]* — represents anything in brackets; match any alphanumerical

  * syntax for *find* — *find STARTING_PATH OPTIONS EXPRESSION*
    - STARTING_PATH — dir to begin search
    - OPTIONS — control behavior to optimize search
    - EXPRESSION — defines query

  * find search criteria
    - -type f — find files
    - -type d — find dirs
    - -type l — find symlinks
    - -name — search for name
    - -size — search by size
    - -iname — search name, case in-sensitive 
    - -not — returns anti-match
    - -maxdepth N — max recursion depth
    - -mtime N — modification time

  * **EX:** *find / -name "\*.conf" -mtime 7*
    - find files by modification time

  * **EX:** *find /var -size +2G*
    - find files by size

  * **EX:** *find . -name "*.conf" -exec chmod 644 '{}' \;*
    - acting on results

### Archive Files
  * Tar - Tape Archiver
    - --create(-c) — create new archive
    - --extract(-x) — extract (from) archive
    - --list(-t) — list files in archive
    - --verbose(-v) — show files being processed
    - --file=(-f) — name archive file
    - -z — GNU tar option compress w/gzip
    - -j — GNU tar option to compress w/bzip2

  * cpio command — copy in, copy out
    - copy file to archive
    - extract file from archive
    - takes list from stdin
    - -o — create output
    - -i — perform extract
    - -d — create destination folder
    - **Ex:** *ls | cpio -o > archive.cpio* — make archive
    - **Ex:** *cpio -id < archive.cpio* — extract archive


## 103.4 Use streams, pipes and redirects
  
### File Descriptors
  * allows dynamic association of integers with data channels
  * allows referencing of i/o streams

  * **3 Standard Communication Channels**
    - stdin — channel 0 or */dev/stdin*
    - stdout — channel 1 or */dev/stdout*
    - stderr — channel 2 or */dev/stderr*

  * **Redirects**
    - reassignment of channel's file descriptor in shell env
    - assumes 0 with no explicit number
    - **EX:** *cat /proc/cpuinfo >/tmp/cpu.txt* — redirect stdout to file
    - **EX:** *cat /proc/cpu_info 2>/tmp/err.txt* — redirect stderr to file
    - syntax *SOURCE CHANNEL#>REDIRECT_LOCATION*
    - &(ampersand) — &> or >& redirect for both stdout/stderr
    - **EX:** *1>&2* — redirect stdin to stderr
    - */dev/null* — redirect here to discard output
    - <(back caret) — redirect from file to std stream
    - see C code example

  * noclobber — stop redirects from overwriting files by default
    - *set -o noclobber* or *set -C*
    - can still append w/noclobber

  * Here document
    - syntax <<EOF with EOF on last kine to end
    - this redirect allows multi-line text

  * Here string
    - syntax <<<"" — string between quote here string
    - similar to here doc but one line

  * pipes — redirect data w/the | char
    - unlike redirects, only left to right
    - only grabs stdout

  * Command substitution
    - *$()* use to capture output of command


## 103.5 Create, monitor and kill processes

### Jobs
  * processes started interactively and abandoned
    - %# — interact w/job
  
  * jobs — command to show current jobs
    - [#] Job ID — first field
    - (+)current job/(-) previous job; second field symbol
    - Stopped — description of status; third field
    - command — description; fourth field
    - -l option — display w/PID

  * Job specifications
    - Commands such as jobs, fg, bg, & kill need a jobspec to act upon
    - *%n* — job ID
    - *%str* — by job command str
    - *%?str* — command line of job contains str
    - *%+* or *%%* — current job (last started in bg or abandoned)
    - *%-* — previous job

### Process Monitoring
  * fg command
    - move reclaim abandoned job

  * bg command
    - abandon task from interact shell

  * kill
    - kill "jobspec" — end process with jobspec instead of PID

  * watch command
    - executes program (default every 2 seconds) to see change over time

  * Killing processes
    - pgrep — get PID w/process name
    - pkill — kill process w/name
    - killall — kill all processes w/name

  * top — dynamic process monitoring
  * ps — static process monitoring
    - *ps --user $USERNAME* — display processes started by user

### Multiplexing
  * Can be useful to ssh and pick up work
  * Also useful to detach from a job and use a terminal while it runs

  * Tmux — modern GNU Screen
    - Client-server model — server provides multiple session w/any number of clients
    - interact selection
    - clients can share sessions


## 103.6 Modify process execution priorities
  * Multi-processing system — more than one thread
    - can be simulated by quickly switching processes on single thread
  * Symmetric multi-processing(SMP) — quickly switch between many processes and multiple threads
    - only one process can control CPU at a time
    - system calls — most processes, transfer CPU control to OS to perform operations
    - system calls are in charge of inter-device communication
    - system can return CPU control to old process or new one
    - system dynamically queues processes to avoid waiting for hardware to be available

  * Preemptive multi-processing — con put running processes back in queue to prioritize other ones
    - uses scheduler so not dependant on system calls

### Linux Scheduler
  * organizes process queue
  * decides which queued thread to execute
  * processes can have many independent; process & thread interchangeable terms
  * scheduling policy/priority — predicates affecting scheduling

  * Real-time — scheduling policy
    - directly scheduled by priority values
    - more important processes preempt less important ones when ready
    - any real-time process is higher priority than a normal one
    - only a few, important processes real-time

  * Normal — scheduling policy
    - lower priority than real-time
    - all usually have same priority
    - define execution priority w/nice value
    - static scheduling — normal priorities derives from nice value; as apposed to dynamic
    - only these processes affected from tuning scheduling policy

  * static priorities — lower number, higher priority
    - real-time — from 0-99
    - normal — form 100-139
    - */proc/1/sched* — static priorities of actives processes
    - for historic reasons, ps can display priorities from -40-99
    - therefore, ps displays normal processes from 0-39

### Process niceness
  * Name comes from idea nicer process make way for other processes
    - range from -20-19
  * Normal processes have default niceness 0
    - only root can decrease below 0
  * nice command — set non-standard nice priority


## 103.7 Search text files using regular expressions
---
• Create simple regular expressions containing several notational elements.
• Understand the differences between basic and extended regular expressions.
• Understand the concepts of special characters, character classes, quantifiers and anchors.
• Use regular expression tools to perform searches through a filesystem or file content.
---
### Regular expressions (REs)
  * character sequence forming generic patterns to match sequences in larger strings
  * simplest RE contains at least one atom
  
  * atom — any one char with or without meaning
    - .(dot) — match any character
    - ^(caret) — match beginning of line
    - $(dollar sign) — match end of line
    - caret & dollar called anchors because at either end

  * Bracket expressions
    - anything inside brackets considered an atom
    - literal characters in brackets, matching any single one in list
    - bracket expressions starting w/caret denote don't correspond to
    - can be ranges [a-z0-9]
    - also accept classes
    - [:alnum:] — any alphanumerical
    - [:alpha:] — alphabetical character
    - [:ascii:] — any ASCII character set
    - [:blank:] — any white-space character
    - [:cntrl:] — control character
    - [:digit:] — numerical; any character 0-9
    - [:graph:] — any printable character excluding space
    - [:lower:] — lowercase character
    - [:punct:] - any printable character
    - [:punct:] — any printable character excluding space or alphanumericals
    - [:space:] — any white-space character
    - [:upper:] — uppercase character
    - [:xdigit:] — hexadecimal digit
    - character classes can be combined with lists and ranges but not be end of range

### Qualifiers
  * atom qualifier
    - adjust reach of any atom
  * qualifiers define atom sequences; contiguous repetition for atom in string is a match
  * piece — substring corresponding to a match

  * POSIX defines basic and extended REs
    - *(star) — match any or no character, literal at start of line
    - +(plus) — match one or more piece containing atom
    - ?(question mark) — match atom weather or not found
    - \(backslash) — escape character

  * Bounds
    - atom qualifier specifying boundaries for atom
    - Basic REs support bounds w/delimiters escaped
  
  * Three forms of bounds in extended REs
    - {i} — atom must appear exactly i times
    - {i,} — atom must appear at least i times
    - {i,j} — atom must appear between i & j times

  * Extended REs can be divided into branches
    - |(bar) — separate independent REs into branches
    - basic REs interpret bar as a literal

  * Extended REs support back references
    - ()(parentheses) — surround any extended RE to back reference
    - **EX:** *([[:digit:]])\1* — match any digit that repeats itself once

  * find command allows extended REs w/ *-regextype posix-extended* or *-regextype egrep*
    - findutils-default — default in find; basically regex clone

  * grep — facilitates inspection of long files w/regex

  * egrep — equivalent to *grep -E*
    - incorporates extra features
    - enables extended REs

  * fgrep — equivalent to *grep -F*
    - does not parse REs

  * sed — stream editor
    - supports tags <TAG> **EX:** *<TIME>*


# 104: Devices, Linux Filesystems, Filesystem HierarchyStandard

## 104.1 Creating Partitions and Filesystems

### Partition
  * logical subset of physical disk
    - disks must be partitioned before use
  * Partition table — stored info on partitions like first/last sector & type

  * Master Boot Record(MRB)
    - Boot sector — first sector of disk; usually GRUB in Linux
    - remnant from early MS-DOS days
    - limitations hinder modern use: max size 2TB, only 4 primary partitions
    - limited to max amount of contiguous unallocated space
    - managed w/fdisk

  * GUID Partition Table
    - made to improve MBR
    - no practical limit on disk size
    - number of partitions only limited by OS
    - commonly used for UEFI
    - supports 128 partitions
    - can partition non-contiguous space together
    - managed w/gdisk
    - stores backups of headers to aid in partition recovery

  * Primary partitions
    - only 4 allowed on MRB
    - for bootable disk, first partition must be primary

  * Extended partitions
    - can be filled w/logical partitions to get around limit
    - treated the same as primary partitions under Linux

  * Creating Filesystem
    - mkfs command symlink to mke2fs command
    - mke2fs defaults altered by name called
    - **EX:** *mkfs.ext4 /dev/sda1* equivalent to *mke2fs -t ext4 /dev/sda1*

    make2fs options:
    - *-b SIZE* — size of data blocks
    - *-c* — checks for bad blocks
    - *-d DIRECTORY* — copied contents of directory to new filesystem
    - *-F* — DANGER! force creation of filesystem, even on mounted device
    - *-n* — simulated creation and displays what would be done
    - *-q* — quiet mode; don't produce output
    - *-U ID* — SET UUID of partition to value
    - *-V* — verbose mode

  * XFS — high-performance filesystem
    - divided into 2 parts: data section & log section
    - data section — all system data stored
    - log section — logs of all filesystem operations
    - log section allocated inside data section by default
    - can log to separate disk for better performance
    - *-l logdev=DEVICE* — specify separate device for log

## 104.2 Maintaining Integrity of Filesystems
  * du
  * df

### Maintaining ext2,3,4 Filesystems
  * fsck — "filesystem check" *fsck /dev/sdb1*
    - NEVER run fsck on mounted filesystem
    - Calls appropriate program for filesystem, assumes ext and calls e2fsck
    - call with fsck -t fs-name or fsck.fs-name to specify fs

### Maintaining XFS filesystems
  * xfs_repair — xfs equivalant to fsck
    - pass -n to scan for errors
  * xfs_db — used to debug an XFS filesystem
  * xfs_fsr — used to defragment the filesystem
    - will attempt to defragment all mouted partitons in */etc/mtab*

### Dealing with open files
  * *target is busy* — displayed when unmounting filesystem with open file
    - lsof —  dsplays lists of processes accessing filesystem 

### Mounting Filesystems on Bootup
  * */etc/fstab* —  contains a discription of filesystems yo be mounted
    - FILESYSTEM — device containg filesystem to be mounted
    - MOUNTPOINT — where to mount filesystem
    - TYPE — filesystem type
    - OPTIONS — options passed to mount
    - DUMP — weather ext filesystems should be considered by *dump* command for backup, usually 0
    - PASS — when none-zero, defines order filesystems will be checked at boot, usually 0
  * Options —
    - atime/noatime — defaultly, every file that is read records access time, disable to speed disk I/O
    - auto/noauto — determins if filesystem can auto-mount with maount -a
    - defaults — passes options: rw, suid, dev, exec, auto, nouser, & async to mount
    - dev/nodev — weather character or block devices in mounted filesystem should be interpreted
    - exec/noexec — allow/deny permission to exec binaries
    - user/nouser — allow/disallow ordinary user to mount filesystem
    - group — Allow user to mount filesystem if they are in owning group
    - owner — Allow user to mount filesystem if they own device containing it
    - suid/nosuid— Allow/disallow SETUID & SETGID bits to take effect
    - ro/rw — mount filesystem as read-only or writable
    - remount — use parameters of mount -o to remount already mounted filesystem (ignores fstab)
    - sync/async — if I/O operations should be done syncronousoly or asyncronously

### Mounting Disks with Systemd
  * Manages mounting of filesystems with a *mount unit*
    - *mount units* — must be places in */etc/systemd/system*
    - mount units are simple text files ending in *.mount*
    - to work, mount unit MUST have same name as mountpoint,
      */mnt/external* would have the mount unit *mnt-external.mount*

  * Automounting a Mount Unit
    - Mount units can automsunt whenever the mount point is accessed
    - Must have a *.automount* file alongside *.mount* file


## 104.5 Manage File Permissions and Ownership
  * Handled w/three-level permission system
    - one for owner
    - one for owning group
    - one for everyone else

### Querying Information about Files and Directories
  * *ls -l* diplays files with permissions
  * next three characters indicate owner permissions
  * next three characters indicate group permissions
  * next three characters indicate general permissions
  * Second column is number of hard links

### Understanding Filetypes
  * - (normal file) — can contain data of any kind & help manage it's data. Can be modified, moved, coppied, & deleted
  * d (directory) — contains files & directories & helps organize the file system. Technically a kind of file
  * l (symbolic link) — pointer to another file or directory in system
  * b (block device) — stands for virtual or phtsical device, usually disk or storage device
  * c (character device) — Stands for virtual or phtsical device, such as terminal /dev/tty0
  * s (socket) — Server as "conduits" passing info between programs

### Understanding Permissions
  * Permissions for files
    - r — read; octal val:4; permission to read file contents
    - w — write; octal val: 2; permission to edit & delete file
    - x — execute; octal val: 1; file can be run as as executable or script
  * Permissions for directories
    - r — read; octal val:4; permission to read directories contents
    - w — write; octal val: 2; permission to create or delete files in directory, if also has x
    - x — execute; octal val: 1; permission to enter directory
  * Without execute permission on directory, user can only see files they have permissions for the file

### Modifying Permissions
 * chmod — used to modify file permissions
   - takes two parameters: file permissions & file to change
   - when run on directory, only acts on that directory
   - has recursive mode (-R) that acts on all files and sub-directories in
  
  * symbol mode
    - change permissions with letters
    - first character indicates whose permissions to alter (ugoa)
    - then to grant (+), revoke (-), or set (=) permissions
    - finally the permission to act on (rwx)
  
  * octal mode
    - change permissions with three-digit value on octal notation
    - permissions are in (rwx) order
    - permission are in (guo) order in sets of 3
    - use 0 for no permission
    - https://aur.archlinux.org/cgit/aur.git/snapshot/dav1d-git-optimized.tar.gz5 would be r+x or 4+0+1
    - 7 would be r+w+x or 4+2+1

  * chown — modify who owns file
    - syntax —  *chown USERNAME:GROUPNAME FILENAME*
    - users or group can be omitted
    - *chown user: file* or *chown user file*
    - can use *chgrp group file*

### Querying Groups
  * *getent group*
    - see existing groups on system

  * *groups user*
    - see groups user belongs to

  * *groupmems -g cdrom -l*
    - see which users belong to group
    - -g to specify group
    - -l to list its members

### Default Permissions
  * For files; *ls -lh file*
    - *-rw-r--r* or 644
    - rw for user, r for group, r for others
  
  * For directories; *ls -lhd dir*
    - *drwxr-xr-x* or 755
    - rwx for user, rx for group, rx for others

  * user mask/unmask
    - determin default permission for every file created
  
  * unmask
    - default format; 0022
    - symbolic mode with -S; *u=rwx, g=rx, o=rx*
    - *unmask u=args,g=args,o=args* to set for session

  * permissions
    - 0 — rw-:rwx
    - 1 — rw-:rw-
    - 2 — r--:r-x
    - 3 — r--:r--
    - 4 — -w-:-wx
    - 5 — -w-:-w-
    - 6 — ---:--x
    - 7 — ---:---

### Special Permissions
  - three other special permissions besides rwx for ugoa

  * Sticky Bit
    - or *restriction deletion flag*
    - octal value 1, symbol t for x in other
    - only applies to directories
    - prevents removing or renaming file except by owner
    - special permission 4 bit octal value, first bit special

  * Set GID
    - or SGID "Set Group ID"
    - octal value 2 or symbol s in group
    - can be applied to executable files or directories
    - on files, makes process run w/privileges of group owning file
    - on directories, makes all sub  files and directories inherit owning group
    - *chmod g+s file/dir* to set SGID

  * Set UID
    - or SUID "Set User ID"
    - octal value 4 or symbol s on user permissions (replacing x)
    - only applies to files
    - similar to SGID but file process is run with users privileges
    - can combine SGID (2) and SUID (4) as 6, such as 6755


## 104.6 Create and Change Hard and Symbolic Links

### Understanding Links
  * Symbolic Links
    - or soft links are pointers to the path of a file, not duplicates
    - still exists when target is deleted
    - *ln -s PATH* to create
    - must take care to avoid breaking link

  * Hard Links
    - must point to file
    - second name for original file, not duplicate
    - points to same inode on disk as file
    - *ln TARGET LINK_NAME* — Target must exist
    - the number t the start of *ls -li* is the inode, hardlins have the same number
    - files have a link count after permissions for number of hardlinks
    - can be moved and renamed


## 104.7 Find System Files and Place Files in the correct location

### The Filesysem Hierarchy Standard
  - All linux follow the *FileSystem Hierarchy Standard* (FHS)
  - The FHS is an effort by the Linux Foundation to standardize the directory structure
  - / — the root directory of the FS
  - /bin — essential binaries
  - /boot — files needed to boot: initrd, kernel, bootloader
  - /dev — Device file like */dev/sda*
  - /etc — host-specific configuration files
  - /home — users personal files
  - /lib — shared libraries needed to boot or run binaries
  - /media — removable media
  - /mnt — mount point for temporarily mounted filesystems
  - /opt — application software packages
  - /root — home directory of superuser
  - /run — run-time variable data
  - /sbin — system binaries
  - /srv — data served by system
  - /tmp — temporary files
  - /usr — read-only user data
  - /proc — virtual filesystem containg data related to running processes
  - /var — variable data written during system operation, including print queue, logs, ect.

### temporary Files
  - used to store data only needed for a short time

  * Location of Temporary Files
    - /tmp — files written here are preserved between program sesions, cleared on reboot
    - /var/tmp — temporary files that persist between boots
    - /run — run-time variable data used by running processes, such as process identifies (pid)
    - /var/run — may be symlinked to run for compatibility

### Finding Files
  - can use find or fd
  - can search for files by attributes like permissions or time accessed

  * Using locate & updatedb
    - find and locate look for files in their database, updated with updatedb
    - simplest way to use locate is w/pattern *locate jpg*
    - updatedb is configured in /etc/updatedb.conf
